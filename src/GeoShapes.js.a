'use strict';

const Promise = require(`bluebird`);
const topojson = require(`topojson`);
const preq = require(`preq`);
const Err = require(`@kartotherian/err`);
const parseWikidataValue = require(`wd-type-parser`);

module.exports = GeoShapes;

class GeoShapes {

  /**
   * @param {string} type
   * @param {object} reqParams
   * @param {string=} reqParams.ids
   * @param {string=} reqParams.query
   * @param {string=} reqParams.idcolumn
   * @param {string=} reqParams.sql
   * @param {object} config
   * @param {object} client
   */
  constructor(type, reqParams, config, client) {
    if (!reqParams.ids && !reqParams.query) throw new Err(`"ids" or "query" parameter must be given`);
    if (reqParams.query && !config.wikidataQueryService) throw new Err(`"query" parameter is not enabled`);

    if (reqParams.ids) {
      this.ids = reqParams.ids.split(`,`).filter(id => id !== ``);
      if (this.ids.length > config.maxidcount) throw new Err(`No more than %d IDs is allowed`, config.maxidcount);
      this.ids.forEach(val => {
        if (!/^Q[1-9][0-9]{0,15}$/.test(val)) throw new Err(`Invalid Wikidata ID`);
      });
    } else {
      this.ids = [];
    }
    this.type = type;
    this.sparqlQuery = reqParams.query;
    this.isDefaultIdColumn = !reqParams.idcolumn;
    this.idColumn = reqParams.idcolumn || `id`;
    this.useGeoJson = !!reqParams.getgeojson;
    this.rawProperties = {};
    this.cleanProperties = {};
    this.reqParams = reqParams;
    this.config = config;
    this.client = client;
  }

  /**
   * Main execution method
   * @return {Promise}
   */
  execute() {
    return Promise.try(
      () => this.runWikidataQuery()
    ).then(
      () => Promise.all([this.runSqlQuery(), this.expandProperties()])
    ).then(
      () => this.wrapResult()
    );
  }

  /**
   * Retrieve all geo shapes for the given list of IDs
   * @return {Promise|undefined}
   */
  runSqlQuery() {
    if (this.ids.length === 0) return;

    const args = [this.type === `geoshape` ? this.config.polygonTable : this.config.lineTable, this.ids];
    const query = this.config.queries.hasOwnProperty(this.reqParams.sql)
      ? this.config.queries[this.reqParams.sql]
      : this.config.queries.default;

    if (query.params) {
      query.params.forEach(param => {
        const paramName = param.name;
        if (!paramName || !this.reqParams.hasOwnProperty(paramName)) {
          // If param name is NOT defined, we always use default,
          // without allowing user to customize it
          args.push(param.default);
        } else {
          const value = this.reqParams[paramName];
          if (!param.regex.test(value)) {
            throw new Error(`Invalid value for param ${paramName}`);
          }
          args.push(value);
        }
      });
    }

    return this.client.query(query.sql, args).then(rows => {
      this.geoRows = rows;
      return this;
    });
  }

  /**
   * @return {Object}
   */
  wrapResult() {
    // If no result, return an empty result set - which greatly simplifies processing
    let features = [];
    if (this.geoRows) {
      features = this.geoRows.map(row => {
        const feature = JSON.parse(`{"type":"Feature","id":"${  row.id  }","properties":{},"geometry":${  row.data  }}`);
        if (this.cleanProperties) {
          const wd = this.cleanProperties[row.id];
          if (wd) {
            feature.properties = wd;
          }
        }
        return feature;
      });
    }

    // TODO: Would be good to somehow monitor the average/min/max number of features
    // core.metrics.count(geoshape.metric, features.length);

    const result = {
      type: `FeatureCollection`,
      features: features
    };
    if (!this.useGeoJson) {
      return topojson.topology({data: result}, {
        // preserve all properties
        "property-transform": feature => feature.properties
      });
    }
    return result;
  }
}
